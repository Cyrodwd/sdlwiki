# CategoryAsyncIO

SDL offers a way to perform I/O asynchronously. This allows an app to read
or write files without waiting for data to actually transfer; the functions
that request I/O never block while the request is fulfilled.

Instead, the data moves in the background and the app can check for results
at their leisure.

This is more complicated that just reading and writing files in a
synchronous way, but it can allow for more efficiency, and never having
framerate drops as the hard drive catches up, etc.

The general usage pattern for async I/O is:

- Create one or more [SDL_AsyncIOQueue](SDL_AsyncIOQueue) objects.
- Open files with [SDL_AsyncIOFromFile](SDL_AsyncIOFromFile).
- Start I/O tasks to the files with [SDL_ReadAsyncIO](SDL_ReadAsyncIO) or
  [SDL_WriteAsyncIO](SDL_WriteAsyncIO), putting those tasks into one of the
  queues.
- Later on, use [SDL_GetAsyncIOResult](SDL_GetAsyncIOResult) on a queue to
  see if any task is finished without blocking. Tasks might finish in any
  order with success or failure.
- When all your tasks are done, close the file with
  [SDL_CloseAsyncIO](SDL_CloseAsyncIO). This also generates a task, since
  it might flush data to disk!

This all works, without blocking, in a single thread, but one can also wait
on a queue in a background thread, sleeping until new results have arrived:

- Call [SDL_WaitAsyncIOResult](SDL_WaitAsyncIOResult) from one or more
  threads to efficiently block until new tasks complete.
- When shutting down, call [SDL_SignalAsyncIOQueue](SDL_SignalAsyncIOQueue)
  to unblock any sleeping threads despite there being no new tasks
  completed.

And, of course, to match the synchronous [SDL_LoadFile](SDL_LoadFile), we
offer [SDL_LoadFileAsync](SDL_LoadFileAsync) as a convenience function.
This will handle allocating a buffer, slurping in the file data, and
null-terminating it; you still get a task handle to check later.

<!-- END CATEGORY DOCUMENTATION -->

## Functions

<!-- DO NOT HAND-EDIT CATEGORY LISTS, THEY ARE AUTOGENERATED AND WILL BE OVERWRITTEN, BASED ON TAGS IN INDIVIDUAL PAGE FOOTERS. EDIT THOSE INSTEAD. -->
<!-- BEGIN CATEGORY LIST: CategoryAsyncIO, CategoryAPIFunction -->
<!-- END CATEGORY LIST -->

## Datatypes

<!-- DO NOT HAND-EDIT CATEGORY LISTS, THEY ARE AUTOGENERATED AND WILL BE OVERWRITTEN, BASED ON TAGS IN INDIVIDUAL PAGE FOOTERS. EDIT THOSE INSTEAD. -->
<!-- BEGIN CATEGORY LIST: CategoryAsyncIO, CategoryAPIDatatype -->
<!-- END CATEGORY LIST -->

## Structs

<!-- DO NOT HAND-EDIT CATEGORY LISTS, THEY ARE AUTOGENERATED AND WILL BE OVERWRITTEN, BASED ON TAGS IN INDIVIDUAL PAGE FOOTERS. EDIT THOSE INSTEAD. -->
<!-- BEGIN CATEGORY LIST: CategoryAsyncIO, CategoryAPIStruct -->
<!-- END CATEGORY LIST -->

## Enums

<!-- DO NOT HAND-EDIT CATEGORY LISTS, THEY ARE AUTOGENERATED AND WILL BE OVERWRITTEN, BASED ON TAGS IN INDIVIDUAL PAGE FOOTERS. EDIT THOSE INSTEAD. -->
<!-- BEGIN CATEGORY LIST: CategoryAsyncIO, CategoryAPIEnum -->
<!-- END CATEGORY LIST -->

## Macros

<!-- DO NOT HAND-EDIT CATEGORY LISTS, THEY ARE AUTOGENERATED AND WILL BE OVERWRITTEN, BASED ON TAGS IN INDIVIDUAL PAGE FOOTERS. EDIT THOSE INSTEAD. -->
<!-- BEGIN CATEGORY LIST: CategoryAsyncIO, CategoryAPIMacro -->
<!-- END CATEGORY LIST -->

----
[CategoryAPICategory](CategoryAPICategory)

